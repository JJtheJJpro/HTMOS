use core::{hint, ptr::write_volatile};
use r_efi::protocols::graphics_output::{self, GraphicsPixelFormat};
use x86_64::instructions::port::Port;

/// A minimal 8×8 ASCII font (first 128 chars). Here we include only ‘ ’ through ‘~’
pub(crate) const FONT8X8: [[u8; 8]; 128] = {
    let mut f = [[0u8; 8]; 128];
    // ' ' (0x20):
    f[0x20] = [
        0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '!' (0x21):
    f[0x21] = [
        0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00000000, 0b00001000,
        0b00000000,
    ];
    // '"' (0x22):
    f[0x22] = [
        0b00010100, 0b00010100, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '#' (0x23):
    f[0x23] = [
        0b00100100, 0b01111110, 0b00100100, 0b00100100, 0b01111110, 0b00100100, 0b00100100,
        0b00000000,
    ];
    // '$' (0x24):
    f[0x24] = [
        0b00111110, 0b01011000, 0b01011000, 0b00111100, 0b00011010, 0b00011010, 0b01111100,
        0b00000000,
    ];
    // '%' (0x25):
    f[0x25] = [
        0b01100010, 0b01100110, 0b00001100, 0b00011000, 0b00110000, 0b01100110, 0b01000110,
        0b00000000,
    ];
    // '&' (0x26):
    f[0x26] = [
        0b00110000, 0b01001000, 0b01001000, 0b00110000, 0b01010100, 0b01001000, 0b00110110,
        0b00000000,
    ];
    // ''' (0x27):
    f[0x27] = [
        0b00001000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '(' (0x28):
    f[0x28] = [
        0b00001000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00001000,
        0b00000000,
    ];
    // ')' (0x29):
    f[0x29] = [
        0b00010000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00010000,
        0b00000000,
    ];
    // '*' (0x2A):
    f[0x2A] = [
        0b00001000, 0b00010100, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '+' (0x2B):
    f[0x2B] = [
        0b00000000, 0b00001000, 0b00001000, 0b00111110, 0b00001000, 0b00001000, 0b00000000,
        0b00000000,
    ];
    // ',' (0x2C):
    f[0x2C] = [
        0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00010000,
        0b00010000,
    ];
    // '-' (0x2D):
    f[0x2D] = [
        0b00000000, 0b00000000, 0b00000000, 0b00111110, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '.' (0x2E):
    f[0x2E] = [
        0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00011000,
        0b00000000,
    ];
    // '/' (0x2F):
    f[0x2F] = [
        0b00000000, 0b00000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000000,
        0b00000000,
    ];
    // '0' (0x30):
    f[0x30] = [
        0b00111100, 0b01000110, 0b01001110, 0b01011010, 0b01110010, 0b01100010, 0b00111100,
        0b00000000,
    ];
    // '1' (0x31):
    f[0x31] = [
        0b00001000, 0b00011000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00111110,
        0b00000000,
    ];
    // '2' (0x32):
    f[0x32] = [
        0b00111000, 0b01000100, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01111110,
        0b00000000,
    ];
    // '3' (0x33):
    f[0x33] = [
        0b01111100, 0b00000010, 0b00000010, 0b00011100, 0b00000010, 0b00000010, 0b01111100,
        0b00000000,
    ];
    // '4' (0x34):
    f[0x34] = [
        0b00000100, 0b00001100, 0b00010100, 0b00100100, 0b01111110, 0b00000100, 0b00000100,
        0b00000000,
    ];
    // '5' (0x35):
    f[0x35] = [
        0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b00000010, 0b00000010, 0b01111100,
        0b00000000,
    ];
    // '6' (0x36):
    f[0x36] = [
        0b00111100, 0b01000000, 0b01000000, 0b01111100, 0b01000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // '7' (0x37):
    f[0x37] = [
        0b01111110, 0b00000010, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b01000000,
        0b00000000,
    ];
    // '8' (0x38):
    f[0x38] = [
        0b00111100, 0b01000010, 0b01000010, 0b00111100, 0b01000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // '9' (0x39):
    f[0x39] = [
        0b00111100, 0b01000010, 0b01000010, 0b00111110, 0b00000010, 0b00000010, 0b00000010,
        0b00000000,
    ];
    // ':' (0x3A):
    f[0x3A] = [
        0b00000000, 0b00011000, 0b00011000, 0b00000000, 0b00000000, 0b00011000, 0b00011000,
        0b00000000,
    ];
    // ';' (0x3B):
    f[0x3B] = [
        0b00000000, 0b00011000, 0b00011000, 0b00000000, 0b00000000, 0b00011000, 0b00111000,
        0b00110000,
    ];
    // '<' (0x3C):
    f[0x3C] = [
        0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b00010000, 0b00001000, 0b00000100,
        0b00000000,
    ];
    // '=' (0x3D):
    f[0x3D] = [
        0b00000000, 0b00000000, 0b00111110, 0b00000000, 0b00111110, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '>' (0x3E):
    f[0x3E] = [
        0b00100000, 0b00010000, 0b00001000, 0b00000100, 0b00001000, 0b00010000, 0b00100000,
        0b00000000,
    ];
    // '?' (0x3F):
    f[0x3F] = [
        0b00111000, 0b01000100, 0b00000100, 0b00001000, 0b00010000, 0b00000000, 0b00010000,
        0b00000000,
    ];
    // '@' (0x40):
    f[0x40] = [
        0b00111100, 0b01000010, 0b01011010, 0b01011010, 0b01011100, 0b01000000, 0b00111110,
        0b00000000,
    ];
    // 'A' (0x41):
    f[0x41] = [
        0b00011000, 0b00100100, 0b01000010, 0b01000010, 0b01111110, 0b01000010, 0b01000010,
        0b00000000,
    ];
    // 'B' (0x42):
    f[0x42] = [
        0b01111100, 0b01000010, 0b01000010, 0b01111100, 0b01000010, 0b01000010, 0b01111100,
        0b00000000,
    ];
    // 'C' (0x43):
    f[0x43] = [
        0b00111110, 0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b00111110,
        0b00000000,
    ];
    // 'D' (0x44):
    f[0x44] = [
        0b01111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01111100,
        0b00000000,
    ];
    // 'E' (0x45):
    f[0x45] = [
        0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b01000000, 0b01000000, 0b01111110,
        0b00000000,
    ];
    // 'F' (0x46):
    f[0x46] = [
        0b01111110, 0b01000000, 0b01000000, 0b01111100, 0b01000000, 0b01000000, 0b01000000,
        0b00000000,
    ];
    // 'G' (0x47):
    f[0x47] = [
        0b00111100, 0b01000000, 0b01000000, 0b01001110, 0b01000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // 'H' (0x48):
    f[0x48] = [
        0b01000010, 0b01000010, 0b01111110, 0b01000010, 0b01000010, 0b01000010, 0b01000010,
        0b00000000,
    ];
    // 'I' (0x49):
    f[0x49] = [
        0b01111110, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b01111110,
        0b00000000,
    ];
    // 'J' (0x4A):
    f[0x4A] = [
        0b01111110, 0b00000010, 0b00000010, 0b00000010, 0b00000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // 'K' (0x4B):
    f[0x4B] = [
        0b01000100, 0b01001000, 0b01010000, 0b01100000, 0b01010000, 0b01001000, 0b01000100,
        0b00000000,
    ];
    // 'L' (0x4C):
    f[0x4C] = [
        0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b01000000, 0b01111110,
        0b00000000,
    ];
    // 'M' (0x4D):
    f[0x4D] = [
        0b01000010, 0b01100110, 0b01011010, 0b01000010, 0b01000010, 0b01000010, 0b01000010,
        0b00000000,
    ];
    // 'N' (0x4E):
    f[0x4E] = [
        0b01000010, 0b01100010, 0b01010010, 0b01001010, 0b01000110, 0b01000010, 0b01000010,
        0b00000000,
    ];
    // 'O' (0x4F):
    f[0x4F] = [
        0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // 'P' (0x50):
    f[0x50] = [
        0b01111100, 0b01000010, 0b01000010, 0b01111100, 0b01000000, 0b01000000, 0b01000000,
        0b00000000,
    ];
    // 'Q' (0x51):
    f[0x51] = [
        0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01001010, 0b01000100, 0b00111010,
        0b00000000,
    ];
    // 'R' (0x52):
    f[0x52] = [
        0b01111100, 0b01000010, 0b01000010, 0b01111100, 0b01001000, 0b01000100, 0b01000010,
        0b00000000,
    ];
    // 'S' (0x53):
    f[0x53] = [
        0b00111110, 0b01000000, 0b01000000, 0b00111100, 0b00000010, 0b00000010, 0b01111100,
        0b00000000,
    ];
    // 'T' (0x54):
    f[0x54] = [
        0b01111110, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000,
        0b00000000,
    ];
    // 'U' (0x55):
    f[0x55] = [
        0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100,
        0b00000000,
    ];
    // 'V' (0x56):
    f[0x56] = [
        0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00100100, 0b00011000,
        0b00000000,
    ];
    // 'W' (0x57):
    f[0x57] = [
        0b01000010, 0b01000010, 0b01001010, 0b01001010, 0b01001010, 0b01001010, 0b00110100,
        0b00000000,
    ];
    // 'X' (0x58):
    f[0x58] = [
        0b01000010, 0b00100100, 0b00011000, 0b00011000, 0b00100100, 0b00100100, 0b01000010,
        0b00000000,
    ];
    // 'Y' (0x59):
    f[0x59] = [
        0b01000010, 0b00100100, 0b00011000, 0b00001000, 0b00001000, 0b00001000, 0b00001000,
        0b00000000,
    ];
    // 'Z' (0x5A):
    f[0x5A] = [
        0b01111110, 0b00000010, 0b00000100, 0b00011000, 0b00100000, 0b01000000, 0b01111110,
        0b00000000,
    ];
    // '[' (0x5B):
    f[0x5B] = [
        0b00011000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00011000,
        0b00000000,
    ];
    // '\' (0x5C):
    f[0x5C] = [
        0b00000000, 0b01000000, 0b00100000, 0b00010000, 0b00001000, 0b00000100, 0b00000010,
        0b00000000,
    ];
    // ']' (0x5D):
    f[0x5D] = [
        0b00011000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00011000,
        0b00000000,
    ];
    // '^' (0x5E):
    f[0x5E] = [
        0b00001000, 0b00010100, 0b00100010, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // '_' (0x5F):
    f[0x5F] = [
        0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b11111111,
        0b00000000,
    ];
    // '`' (0x60):
    f[0x60] = [
        0b00010000, 0b00001000, 0b00000000, 0b00000000, 0b00000000, 0b00000000, 0b00000000,
        0b00000000,
    ];
    // 'a' (0x61):
    f[0x61] = [
        0b00000000, 0b00000000, 0b00111000, 0b00000100, 0b00011100, 0b00100100, 0b00011100,
        0b00000000,
    ];
    // 'b' (0x62):
    f[0x62] = [
        0b00100000, 0b00100000, 0b00100000, 0b00111000, 0b00100100, 0b00100100, 0b00111000,
        0b00000000,
    ];
    // 'c' (0x63):
    f[0x63] = [
        0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00100000, 0b00100000, 0b00011000,
        0b00000000,
    ];
    // 'd' (0x64):
    f[0x64] = [
        0b00000100, 0b00000100, 0b00000100, 0b00011100, 0b00100100, 0b00100100, 0b00011100,
        0b00000000,
    ];
    // 'e' (0x65):
    f[0x65] = [
        0b00000000, 0b00000000, 0b00011000, 0b00100100, 0b00111100, 0b00100000, 0b00011100,
        0b00000000,
    ];
    // 'f' (0x66):
    f[0x66] = [
        0b00001000, 0b00010100, 0b00010000, 0b00111000, 0b00010000, 0b00010000, 0b00010000,
        0b00000000,
    ];
    // 'g' (0x67):
    f[0x67] = [
        0b00000000, 0b00011100, 0b00101000, 0b00010000, 0b00100000, 0b00011000, 0b00100100,
        0b00011000,
    ];
    // 'h' (0x68):
    f[0x68] = [
        0b00100000, 0b00100000, 0b00100000, 0b00111000, 0b00100100, 0b00100100, 0b00100100,
        0b00000000,
    ];
    // 'i' (0x69):
    f[0x69] = [
        0b00000000, 0b00001000, 0b00000000, 0b00011000, 0b00001000, 0b00001000, 0b00011100,
        0b00000000,
    ];
    // 'j' (0x6A):
    f[0x6A] = [
        0b00000000, 0b00000100, 0b00000000, 0b00011100, 0b00000100, 0b01000100, 0b00100100,
        0b00011000,
    ];
    // 'k' (0x6B):
    f[0x6B] = [
        0b00100000, 0b00100000, 0b00100100, 0b00101000, 0b00110000, 0b00101000, 0b00100100,
        0b00000000,
    ];
    // 'l' (0x6C):
    f[0x6C] = [
        0b00011000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00001000, 0b00011100,
        0b00000000,
    ];
    // 'm' (0x6D):
    f[0x6D] = [
        0b00000000, 0b00000000, 0b00000000, 0b00110100, 0b01001010, 0b01001010, 0b01001010,
        0b00000000,
    ];
    // 'n' (0x6E):
    f[0x6E] = [
        0b00000000, 0b00000000, 0b00000000, 0b00111000, 0b00100100, 0b00100100, 0b00100100,
        0b00000000,
    ];
    // 'o' (0x6F):
    f[0x6F] = [
        0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00100100, 0b00100100, 0b00011000,
        0b00000000,
    ];
    // 'p' (0x70):
    f[0x70] = [
        0b00000000, 0b00000000, 0b00011000, 0b00100100, 0b00111000, 0b00100000, 0b00100000,
        0b00100000,
    ];
    // 'q' (0x71):
    f[0x71] = [
        0b00000000, 0b00000000, 0b00011000, 0b00100100, 0b00011100, 0b00000100, 0b00000100,
        0b00000010,
    ];
    // 'r' (0x72):
    f[0x72] = [
        0b00000000, 0b00000000, 0b00000000, 0b00011000, 0b00010100, 0b00010000, 0b00010000,
        0b00000000,
    ];
    // 's' (0x73):
    f[0x73] = [
        0b00000000, 0b00000000, 0b00011100, 0b00100000, 0b00011000, 0b00000100, 0b00111000,
        0b00000000,
    ];
    // 't' (0x74):
    f[0x74] = [
        0b00000000, 0b00000000, 0b00010000, 0b00111000, 0b00010000, 0b00010000, 0b00001000,
        0b00000000,
    ];
    // 'u' (0x75):
    f[0x75] = [
        0b00000000, 0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00100100, 0b00011100,
        0b00000000,
    ];
    // 'v' (0x76):
    f[0x76] = [
        0b00000000, 0b00000000, 0b00000000, 0b00100010, 0b00100010, 0b00010100, 0b00001000,
        0b00000000,
    ];
    // 'w' (0x77):
    f[0x77] = [
        0b00000000, 0b00000000, 0b00000000, 0b01000010, 0b01001010, 0b01001010, 0b00110100,
        0b00000000,
    ];
    // 'x' (0x78):
    f[0x78] = [
        0b00000000, 0b00000000, 0b00100010, 0b00010100, 0b00001000, 0b00010100, 0b00100010,
        0b00000000,
    ];
    // 'y' (0x79):
    f[0x79] = [
        0b00000000, 0b00000000, 0b00100100, 0b00100100, 0b00011100, 0b00000100, 0b00100100,
        0b00011000,
    ];
    // 'z' (0x7A):
    f[0x7A] = [
        0b00000000, 0b00000000, 0b00000000, 0b00111100, 0b00001000, 0b00010000, 0b00111100,
        0b00000000,
    ];
    f
};

/// Draw one pixel into the framebuffer, handling RGB vs BGR formats
pub(crate) fn put_pixel(
    fb_ptr: *mut u8,
    pitch: usize,
    x: usize,
    y: usize,
    color: [u8; 3],
    format: GraphicsPixelFormat,
) {
    let bytes_per_pixel = 4; // we’ll assume 32-bpp (you can read info.pixel_format().bytes_per_pixel())
    let offset = y * pitch * bytes_per_pixel + x * bytes_per_pixel;
    let px = unsafe { fb_ptr.add(offset) };
    unsafe {
        match format {
            graphics_output::PIXEL_RED_GREEN_BLUE_RESERVED_8_BIT_PER_COLOR => {
                write_volatile(px, color[0]); // R
                write_volatile(px.add(1), color[1]); // G
                write_volatile(px.add(2), color[2]); // B
            }
            graphics_output::PIXEL_BLUE_GREEN_RED_RESERVED_8_BIT_PER_COLOR => {
                write_volatile(px, color[2]); // B
                write_volatile(px.add(1), color[1]); // G
                write_volatile(px.add(2), color[0]); // R
            }
            _ => {} // other formats omitted for brevity
        }
    }
}

/// Draw one 8×8 character at cell (cx, cy), where each cell is 8×8 pixels
pub fn draw_char(
    fb_ptr: *mut u8,
    pitch: usize,
    cx: usize,
    cy: usize,
    ch: u8,
    fg: [u8; 3],
    bg: [u8; 3],
    format: GraphicsPixelFormat,
) {
    let glyph = FONT8X8[ch as usize];
    let base_x = cx * 8;
    let base_y = cy * 8;
    for row in 0..8 {
        let bits = glyph[row];
        for col in 0..8 {
            let color = if (bits >> (7 - col)) & 1 == 1 { fg } else { bg };
            put_pixel(fb_ptr, pitch, base_x + col, base_y + row, color, format);
        }
    }
}

/// Draw a whole string starting at cell (cx, cy)
//pub(super) fn draw_string(
//    fb_ptr: *mut u8,
//    pitch: usize,
//    cx: usize,
//    cy: usize,
//    s: &str,
//    fg: [u8; 3],
//    bg: [u8; 3],
//    format: PixelFormat,
//) {
//    for (i, &b) in s.as_bytes().iter().enumerate() {
//        draw_char(fb_ptr, pitch, cx + i, cy, b, fg, bg, format);
//    }
//}

// Simple US‐layout Scancode Set 1 → ASCII (printable only)
static SCANCODE_MAP: [u8; 128] = {
    let mut m = [0; 128];
    m[0x02] = b'1';
    m[0x03] = b'2';
    m[0x04] = b'3';
    m[0x05] = b'4';
    m[0x06] = b'5';
    m[0x07] = b'6';
    m[0x08] = b'7';
    m[0x09] = b'8';
    m[0x0A] = b'9';
    m[0x0B] = b'0';
    m[0x10] = b'q';
    m[0x11] = b'w';
    m[0x12] = b'e';
    m[0x13] = b'r';
    m[0x14] = b't';
    m[0x15] = b'y';
    m[0x16] = b'u';
    m[0x17] = b'i';
    m[0x18] = b'o';
    m[0x19] = b'p';
    m[0x1E] = b'a';
    m[0x1F] = b's';
    m[0x20] = b'd';
    m[0x21] = b'f';
    m[0x22] = b'g';
    m[0x23] = b'h';
    m[0x24] = b'j';
    m[0x25] = b'k';
    m[0x26] = b'l';
    m[0x2C] = b'z';
    m[0x2D] = b'x';
    m[0x2E] = b'c';
    m[0x2F] = b'v';
    m[0x30] = b'b';
    m[0x31] = b'n';
    m[0x32] = b'm';
    m[0x1C] = b'\r'; // Enter
    m[0x0E] = 8; // Backspace → ASCII BS
    m
};

/// Blocking read of one raw scancode (Set 1)
pub fn read_scancode() -> u8 {
    let mut status = Port::<u8>::new(0x64);
    let mut data = Port::<u8>::new(0x60);

    // Wait until output buffer full (bit 0 = 1)
    loop {
        if unsafe { status.read() } & 1 == 1 {
            break;
        }
    }
    unsafe { data.read() }
}

/// Read one ASCII byte (blocking), converting scancodes.
/// Returns `0` on error/unmapped scancode.
pub fn read_ascii() -> u8 {
    let mut sc = read_scancode();
    // ignore key‐releases (high bit set)
    while sc & 0x80 != 0 {
        sc = read_scancode();
    }
    SCANCODE_MAP[sc as usize]
}

/// Read a line into `buf`, returning number of bytes (excluding `\r`).
/// Echoes characters back via `vga_print` (or your GOP text blitter).
pub fn read_line(buf: &mut [u8]) -> usize {
    let mut len = 0;
    loop {
        let c = read_ascii();
        match c {
            0 => continue, // unmapped or key‐release
            b'\r' => {
                // echo newline
                crate::println!();
                break;
            }
            8 => {
                // Backspace
                if len > 0 {
                    len -= 1;
                    // erase on screen
                    crate::print!("\u{8} \u{8}");
                }
            }
            ch if len < buf.len() => {
                buf[len] = ch;
                len += 1;
                // echo
                let s = unsafe { core::str::from_utf8_unchecked(&buf[len - 1..len]) };
                crate::print!("{s}");
            }
            _ => {} // buffer full: drop extra chars
        }
    }
    len
}

pub fn rdtsc() -> u64 {
    let low: u32;
    let high: u32;
    unsafe {
        core::arch::asm!(
            "rdtsc",
            out("eax") low,
            out("edx") high,
            options(nomem, nostack, preserves_flags),
        );
    }
    ((high as u64) << 32) | (low as u64)
}

const CPU_FREQ_HZ: u64 = 3_000_000_000;

pub fn sleep_ms(ms: u64) {
    let ticks_to_wait = CPU_FREQ_HZ / 1_000 * ms;
    let start = rdtsc();
    while rdtsc().wrapping_sub(start) < ticks_to_wait {
        hint::spin_loop();
    }
}
